// This file is generated by Save As Snippet
// For detail, check vscode snippet syntax
// https://code.visualstudio.com/docs/editor/userdefinedsnippets#_creating-your-own-snippets
{
  "GetDrive": {
    "prefix": "GetDrive",
    "scope": "cpp",
    "body": [
      "/*! \\fn void GetDrive(LPCTSTR lpszPath, char** pDriveName)\r",
      " *  \\brief 指定されたファイルパスからファイルのタイトル名を取得する。\r",
      " *  \\param lpszPath 指定したパスのファイルの拡張子名が格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\param pDriveName ドライブ名を格納したバッファへのポインタを格納するポインタ指定する。\r",
      "*/\r",
      "void GetDrive(LPCTSTR lpszPath, char** pDriveName)\r",
      "{\r",
      "\tif(!lpszPath || !pDriveName){\r",
      "\t\treturn;\r",
      "\t}\r",
      "\tconst char* driveout = strstr(lpszPath, \"\\\\\");\r",
      "\tif(!driveout){\r",
      "\t\treturn;\r",
      "\t}\r",
      "\r",
      "\tint len = strlen(lpszPath) - strlen(driveout) - 1;\r",
      "\tif(len > 0){\r",
      "\t\t*pDriveName = (char*)malloc(len + 1);//new char[len + 1];\r",
      "\t\tif (*pDriveName == NULL) {\r",
      "\t\t\treturn;\r",
      "\t\t}\r",
      "\t\tstrncpy(*pDriveName, lpszPath, len);\r",
      "\t\t(*pDriveName)[len] = 0x00;\r",
      "\t}\r",
      "\r",
      "}"
    ],
    "description": ""
  },

  "GetModuleDirectory": {
    "prefix": "GetModuleDirectory",
    "scope": "cpp",
    "body": [
      "/*! \\fn LPCTSTR GetModuleDirectory()\r",
      " *  \\brief モジュールのディレクトリへのパスを取得する。\r",
      " *  \\return モジュールのディレクトリへのパスが格納された NULL で終わる文字列へのポインタが返る。\r",
      "*/\r",
      "LPCTSTR GetModuleDirectory()\r",
      "{\r",
      "\tstatic TCHAR theModuleDirectory[_MAX_DIR] = {0};\r",
      "\r",
      "\tif (_tcslen(theModuleDirectory) == 0){\r",
      "\t\tTCHAR szFullPath[_MAX_PATH];\r",
      "\t\tTCHAR szDir[_MAX_DIR];\r",
      "\t\tTCHAR szDrive[_MAX_DRIVE];\r",
      "\r",
      "\t\t::GetModuleFileName(NULL, szFullPath, _MAX_PATH);\r",
      "\r",
      "\t\t_tsplitpath(szFullPath, szDrive, szDir, NULL, NULL);\r",
      "\t\t_sntprintf(theModuleDirectory, sizeof(theModuleDirectory) -1, _T(\"%s%s\"), szDrive, szDir);\r",
      "\t}\r",
      "\r",
      "\treturn theModuleDirectory;\r",
      "}"
    ],
    "description": ""
  },

  "GetFileTitle": {
    "prefix": "GetFileTitle",
    "scope": "cpp",
    "body": [
      "/*! \\fn void GetFileTitle(LPCTSTR lpszPath, char* pFileTitle)\r",
      " *  \\brief 指定されたファイルパスからファイルのタイトル名を取得する。\r",
      " *  \\param lpszPath ファイルパスが格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\param pFileTitle ファイルのタイトル名を格納したバッファへのポインタを格納するポインタ指定する。\r",
      "*/\r",
      "void GetFileTitle(LPCTSTR lpszPath, char* pFileTitle)\r",
      "{\r",
      "\tchar* filename = PathFindFileName(lpszPath);\r",
      "\tchar* fileext = PathFindExtension(lpszPath);\r",
      "\tif(filename && fileext){\r",
      "\t\t_snprintf(pFileTitle, fileext - filename, \"%s\", filename);\r",
      "\t\tpFileTitle[fileext - filename] = '\\0';\r",
      "\t}\r",
      "}"
    ],
    "description": ""
  },

  "IsFile": {
    "prefix": "IsFile",
    "scope": "cpp",
    "body": [
      "/*! \\fn BOOL IsFile(LPCTSTR lpszPath)\r",
      " *  \\brief パスがファイルであるか判定する。\r",
      " *  \\param lpszPath ファイルパスが格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\return TRUE:パスはファイルを指す。\r",
      "*/\r",
      "BOOL IsFile(LPCTSTR lpszPath)\r",
      "{\r",
      "\tif (lpszPath == NULL) return FALSE;\r",
      "\tDWORD dwResult = ::GetFileAttributes(lpszPath);\r",
      "\tif ((long)dwResult == -1) return FALSE;\r",
      "\tif (dwResult & FILE_ATTRIBUTE_DIRECTORY) return FALSE;\r",
      "\treturn TRUE;\r",
      "}"
    ],
    "description": ""
  },

  "IsDirectory": {
    "prefix": "IsDirectory",
    "scope": "cpp",
    "body": [
      "/*! \\fn BOOL IsDirectory(LPCTSTR lpszPath)\r",
      " *  \\brief パスがディレクトリであるか判定する。\r",
      " *  \\param lpszPath ファイルパスが格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\return TRUE:パスはディレクトリを指す。\r",
      "*/\r",
      "BOOL IsDirectory(LPCTSTR lpszPath)\r",
      "{\r",
      "\tif (lpszPath == NULL) return FALSE;\r",
      "\tDWORD dwResult = ::GetFileAttributes(lpszPath);\r",
      "\tif ((long)dwResult == -1) return FALSE;\r",
      "\tif (dwResult & FILE_ATTRIBUTE_DIRECTORY) return TRUE;\r",
      "\treturn FALSE;\r",
      "}"
    ],
    "description": ""
  },

  "ForceToDeleteFile": {
    "prefix": "ForceToDeleteFile",
    "scope": "cpp",
    "body": [
      "/*! \\fn BOOL ForceToDeleteFile(LPCTSTR lpszPath)\r",
      " *  \\brief ファイルを強制的に削除する。\r",
      " *  \\param lpszPath ファイルパスが格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\return TRUE:成功\r",
      "*/\r",
      "BOOL ForceToDeleteFile(LPCTSTR lpszPath)\r",
      "{\r",
      "\tif (!IsFile(lpszPath)) return FALSE;\r",
      "\r",
      "\tif (!ModifyFileAttributes(\r",
      "\t\tlpszPath,\r",
      "\t\tFILE_ATTRIBUTE_SYSTEM |\r",
      "\t\tFILE_ATTRIBUTE_TEMPORARY |\r",
      "\t\tFILE_ATTRIBUTE_HIDDEN |\r",
      "\t\tFILE_ATTRIBUTE_READONLY,\r",
      "\t\tFILE_ATTRIBUTE_NORMAL))\r",
      "\t{\r",
      "\t\treturn FALSE;\r",
      "\t}\r",
      "\tBOOL res = ::DeleteFile(lpszPath);\r",
      "\tif (!res) {\r",
      "\t\tDWORD dwErr = GetLastError();\r",
      "\t\tchar log[256] = {0};\r",
      "\t\t_snprintf(log, 255, \"DeleteFile failed for %s: Error = %08X\", lpszPath, dwErr);\r",
      "\t\tWriteToLogBuf(LOG_WARNING, log);\r",
      "\t\tLPVOID lpMsgBuf;\r",
      "\t\tFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dwErr, MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT), (LPTSTR)&lpMsgBuf, 0, NULL);\r",
      "\t\tWriteToLogBuf(LOG_DEBUG, (char*)lpMsgBuf);\r",
      "\t\tLocalFree(lpMsgBuf);\r",
      "\t}\r",
      "\treturn res;\r",
      "}"
    ],
    "description": ""
  },

  "ModifyFileAttributes": {
    "prefix": "ModifyFileAttributes",
    "scope": "cpp",
    "body": [
      "/*! \\fn BOOL ModifyFileAttributes(LPCTSTR lpszPath, DWORD dwRem, DWORD dwAdd)\r",
      " *  \\brief ファイル属性を変更する。\r",
      " *  \\param lpszPath ファイルパスが格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\param dwRem 削除するファイル属性を指定する。\r",
      " *  \\param dwAdd 追加するファイル属性を指定する。\r",
      " *  \\return TRUE:成功\r",
      "*/\r",
      "BOOL ModifyFileAttributes(LPCTSTR lpszPath, DWORD dwRem, DWORD dwAdd)\r",
      "{\r",
      "\tif(!lpszPath){\r",
      "\t\treturn FALSE;\r",
      "\t}\r",
      "\tDWORD dwAttributes = ::GetFileAttributes(lpszPath);\r",
      "\tif (dwAttributes == 0xFFFFFFFF) return FALSE;\r",
      "\r",
      "\tdwAttributes |= dwAdd;\r",
      "\tdwAttributes &= ~dwRem;\r",
      "\r",
      "\treturn ::SetFileAttributes(lpszPath, dwAttributes);\r",
      "}"
    ],
    "description": ""
  },

  "ForceRemoveDirectory": {
    "prefix": "ForceRemoveDirectory",
    "scope": "cpp",
    "body": [
      "/*! \\fn long ForceRemoveDirectory(LPCTSTR current_path)\r",
      " *  \\brief ディレクトリを強制的に削除する。\r",
      " *  \\param current_path ディレクトリパスが格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\return TRUE:成功\r",
      "*/\r",
      "long ForceRemoveDirectory(LPCTSTR current_path)\r",
      "{\r",
      "\tlong find_count = 0;\r",
      "\t//ファイル検出\r",
      "\t{\r",
      "\t\tchar* src_path = (char*)malloc(256);\r",
      "\t\tWIN32_FIND_DATA wfData = {0};\r",
      "\t\tchar* pFindFile = (char*)malloc(256);\r",
      "\t\t_snprintf(pFindFile, 255, \"%s\\\\*.*\", current_path);\r",
      "\t\tHANDLE hFind = ::FindFirstFile(pFindFile, &wfData);\r",
      "\t\tif(hFind != INVALID_HANDLE_VALUE){\r",
      "\t\t\tchar* sub_src_dir_path = (char*)malloc(256);\r",
      "\t\t\tFILETIME ftLocalTime = {0};\r",
      "\t\t\tSYSTEMTIME stCreateDate = {0};\r",
      "\t\t\tSYSTEMTIME stLastWriteTime = {0};\r",
      "\t\t\t//フォルダ内のファイル全部探す\r",
      "\t\t\tdo{\r",
      "\t\t\t\tif(stricmp(wfData.cFileName, \"..\") == 0 || stricmp(wfData.cFileName, \".\") == 0){\r",
      "\t\t\t\t\tcontinue;\r",
      "\t\t\t\t}\r",
      "\t\t\t\t++find_count;\r",
      "\t\t\t\tif(wfData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){\r",
      "\t\t\t\t\t//サブディレクトリの移動\r",
      "\t\t\t\t\tmemset(sub_src_dir_path, 0x00, 256);\r",
      "\t\t\t\t\t_snprintf(sub_src_dir_path, 255, \"%s\\\\%s\", current_path, wfData.cFileName);\r",
      "\t\t\t\t\t//再起\r",
      "\t\t\t\t\tif(_ForceRemoveDirectory(sub_src_dir_path) == 0){\r",
      "\t\t\t\t\t\tif(RemoveDirectory(sub_src_dir_path)){\r",
      "\t\t\t\t\t\t\t--find_count;\r",
      "\t\t\t\t\t\t}\r",
      "\t\t\t\t\t}\r",
      "\t\t\t\t}else{\r",
      "\t\t\t\t\t//ファイル削除\r",
      "\t\t\t\t\tmemset(sub_src_dir_path, 0x00, 256);\r",
      "\t\t\t\t\t_snprintf(sub_src_dir_path, 255, \"%s\\\\%s\", current_path, wfData.cFileName);\r",
      "\t\t\t\t\tif(ForceToDeleteFile(sub_src_dir_path)){\r",
      "\t\t\t\t\t\t--find_count;\r",
      "\t\t\t\t\t}\r",
      "\t\t\t\t}\r",
      "\t\t\t}while(FindNextFile(hFind, &wfData));\r",
      "\t\t\tFindClose(hFind);\r",
      "\t\t\tfree(sub_src_dir_path);\r",
      "\t\t}\r",
      "\t\tfree(pFindFile);\r",
      "\t\tfree(src_path);\r",
      "\t}\r",
      "\r",
      "\treturn find_count;\r",
      "}"
    ],
    "description": ""
  },

  "ForceToMoveFile": {
    "prefix": "ForceToMoveFile",
    "scope": "cpp",
    "body": [
      "/*! \\fn BOOL ForceToMoveFile(LPCTSTR lpszSrc, LPCTSTR lpszDst)\r",
      " *  \\brief ファイルを強制的に移動する。\r",
      " *  \\param lpszSrc 元のファイルパスが格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\param lpszDst 移動後のファイルパスが格納された NULL で終わる文字列へのポインタを指定する。\r",
      " *  \\return TRUE:成功\r",
      "*/\r",
      "BOOL ForceToMoveFile(LPCTSTR lpszSrc, LPCTSTR lpszDst)\r",
      "{\r",
      "\tif(!lpszSrc || !lpszDst){\r",
      "\t\treturn FALSE;\r",
      "\t}\r",
      "\r",
      "\tDWORD dwAttributes = ::GetFileAttributes(lpszDst);\r",
      "\r",
      "\tif (dwAttributes != 0xFFFFFFFF)\r",
      "\t{\r",
      "\t\tif (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)\r",
      "\t\t{\r",
      "\t\t\treturn FALSE;\r",
      "\t\t}\r",
      "\r",
      "\t\tif (!ModifyFileAttributes(\r",
      "\t\t\tlpszDst,\r",
      "\t\t\tFILE_ATTRIBUTE_SYSTEM |\r",
      "\t\t\tFILE_ATTRIBUTE_TEMPORARY |\r",
      "\t\t\tFILE_ATTRIBUTE_HIDDEN |\r",
      "\t\t\tFILE_ATTRIBUTE_READONLY,\r",
      "\t\t\tFILE_ATTRIBUTE_NORMAL))\r",
      "\t\t{\r",
      "\t\t\treturn FALSE;\r",
      "\t\t}\r",
      "\t}\r",
      "\tBOOL res = ::MoveFileEx(lpszSrc, lpszDst, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH | MOVEFILE_COPY_ALLOWED);\r",
      "\tif (!res) {\r",
      "\t\tDWORD dwErr = GetLastError();\r",
      "\t\tchar log[256] = {0};\r",
      "\t\t_snprintf(log, 255, \"MoveFileEx failed for %s: Error = %08X\", lpszSrc, dwErr);\r",
      "\t\tWriteToLogBuf(LOG_WARNING, log);\r",
      "\t\tLPVOID lpMsgBuf;\r",
      "\t\tFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dwErr, MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT), (LPTSTR)&lpMsgBuf, 0, NULL);\r",
      "\t\tWriteToLogBuf(LOG_DEBUG, (char*)lpMsgBuf);\r",
      "\t\tLocalFree(lpMsgBuf);\r",
      "\t}\r",
      "\treturn res;\r",
      "}"
    ],
    "description": ""
  },

  "CreateForder": {
    "prefix": "CreateForder",
    "scope": "cpp",
    "body": [
      "/*! \\fn BOOL CreateForder(LPTSTR lpszPath)\r",
      " *  \\brief フォルダを作成する。\r",
      " *  \\param lpszPath 作成するフォルダへの絶対パス\r",
      " *  \\return TRUE:成功\r",
      "*/\r",
      "BOOL CreateForder(LPTSTR lpszPath)\r",
      "{\r",
      "\tif (lpszPath && (_tcslen(lpszPath) > 0))\r",
      "\t{\r",
      "\t\tTCHAR szDir[_MAX_PATH] = {0};\r",
      "\t\tTCHAR* szFileName = _tcsrchr(lpszPath, _T('\\\\'));\r",
      "\t\t_tcsncpy(szDir, lpszPath, (szFileName - lpszPath));\r",
      "\r",
      "\t\treturn ::CreateDirectory(szDir, NULL);\r",
      "\t}\r",
      "\treturn FALSE;\r",
      "}"
    ],
    "description": ""
  },

  "IsFolderExists": {
    "prefix": "IsFolderExists",
    "scope": "cpp",
    "body": [
      "/*! \\fn BOOL IsFolderExists(LPCTSTR lpszFolderName)\r",
      " *  \\brief フォルダの存在チェック\r",
      " *  \\param lpszFolderName フォルダのパス\r",
      " *  \\return\r",
      "*/\r",
      "BOOL IsFolderExists(LPCTSTR lpszFolderName)\r",
      "{\r",
      "\tif(!lpszFolderName){\r",
      "\t\treturn FALSE;\r",
      "\t}\r",
      "\tif (PathFileExists(lpszFolderName)) {\r",
      "\t    if (PathIsDirectory(lpszFolderName)) {\r",
      "\t        return TRUE;\r",
      "\t    }\r",
      "\t}\r",
      "\treturn FALSE;\r",
      "}"
    ],
    "description": ""
  },

  "GetDiskFreeSpaceExEr": {
    "prefix": "GetDiskFreeSpaceExEr",
    "scope": "cpp",
    "body": [
      "/*! \\fn BOOL GetDiskFreeSpaceExEr(LPCTSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)\r",
      " * \\brief 空き容量の取得\r",
      " * \\param lpDirectoryName 空き容量を調べるフォルダパス\r",
      " * \\param lpFreeBytesAvailable\r",
      " * \\param lpTotalNumberOfBytes\r",
      " * \\param lpTotalNumberOfFreeBytes\r",
      " * \\return TRUE:正常終了 FALSE:異常終了\r",
      " */\r",
      "BOOL GetDiskFreeSpaceExEr(LPCTSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable,\r",
      "  PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)\r",
      "{\r",
      "\tUINT tmpMode = SetErrorMode(SEM_FAILCRITICALERRORS);\r",
      "\tBOOL b_state = ::GetDiskFreeSpaceEx(lpDirectoryName, lpFreeBytesAvailable,\r",
      "\t\t\t\t\t\t\t\tlpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);\r",
      "\tif(!b_state){\r",
      "\t\tDWORD err_id = GetLastError();\r",
      "\t\tchar log[256] = {0};\r",
      "\t\t_snprintf(log, 255, \"GetDiskFreeSpaceEx failed for %s: Error = %08X\", lpDirectoryName, err_id);\r",
      "\t\tWriteToLogBuf(LOG_WARNING, log);\r",
      "\r",
      "\t\tLPVOID lpMsgBuf;\r",
      "\t\tFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\r",
      "\t\t\tNULL, err_id, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &lpMsgBuf, 0, NULL);\r",
      "\t\tWriteToLogBuf(LOG_DEBUG, (char*)lpMsgBuf);\r",
      "\t\tLocalFree(lpMsgBuf);\r",
      "\t}\r",
      "\tSetErrorMode(tmpMode);\r",
      "\treturn b_state;\r",
      "}"
    ],
    "description": ""
  },

  "GetCurrentDateTimeString": {
    "prefix": "GetCurrentDateTimeString",
    "scope": "cpp",
    "body": [
      "/**\r",
      " *\tGet current date time string\r",
      " *\t@param[out]\toutString : the string buffer\r",
      " *\t@param[in]\tinStringSize : the string buffer size\r",
      "**/\r",
      "void GetCurrentDateTimeString(char *outString, size_t inStringSize)\r",
      "{\r",
      "\ttime_t current = time(0);\r",
      "\tstruct tm* local = localtime(&current);\r",
      "\t_snprintf_s(outString, inStringSize, inStringSize - 1,\r",
      "\t\t\t\t\"%04d/%02d/%02d %02d:%02d\",\r",
      "\t\t\t\tlocal->tm_year + 1900, local->tm_mon + 1, local->tm_mday,\r",
      "\t\t\t\tlocal->tm_hour, local->tm_min);\r",
      "}"
    ],
    "description": ""
  },

  "ReplaceString": {
    "prefix": "ReplaceString",
    "scope": "cpp",
    "body": [
      "/**\r",
      " *\tFind and replace all matching inSearch string by inReplace string\r",
      " *\t@param[in] inSubjectStr : Input string\r",
      " *\t@param[in] inSearchStr : Search string\r",
      " *\t@param[in] inReplaceStr : Replace string\r",
      " *\t@retval output string after replacing.\r",
      "**/\r",
      "std::string ReplaceString(std::string inSubjectStr, const std::string& inSearchStr, const std::string& inReplaceStr)\r",
      "{\r",
      "\tsize_t pos = 0;\r",
      "\twhile ((pos = inSubjectStr.find(inSearchStr, pos)) != std::string::npos) {\r",
      "\t\tinSubjectStr.replace(pos, inSearchStr.length(), inReplaceStr);\r",
      "\t\tpos += inReplaceStr.length();\r",
      "\t}\r",
      "\r",
      "\treturn inSubjectStr;\r",
      "}"
    ],
    "description": ""
  }

}